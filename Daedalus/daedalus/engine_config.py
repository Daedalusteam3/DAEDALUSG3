"""
engine_config.py

Helper module to load the simulated network configuration 
generated by `prep_red_y_frecuencias_simuladas.py`.

Loads:
- salida_red_simulada/lines_config_simulated.json
- salida_red_simulada/network_maps.json

And exposes high-level functions and a class for use in the
Intelligence Engine without worrying about paths or formats.
"""

from pathlib import Path
import json
from typing import Dict, List, Any, Optional

# -----------------------------
# 1. Default Paths
# -----------------------------

# Folder where this file (engine_config.py) is located
THIS_DIR = Path(__file__).resolve().parent

# Folder where the JSON files were saved
DEFAULT_OUT_DIR = THIS_DIR / "salida_red_simulada"

LINES_CONFIG_FILE = DEFAULT_OUT_DIR / "lines_config_simulated.json"
NETWORK_MAPS_FILE = DEFAULT_OUT_DIR / "network_maps.json"


# -----------------------------
# 2. Basic Load Functions
# -----------------------------

def load_lines_config(path: Optional[Path] = None) -> Dict[str, Any]:
    """
    Loads the JSON with the simulated line and frequency configuration.

    Returns a dictionary with:
      - "cycle_time_h": { line_id -> hours per cycle/round trip }
      - "prior_freq": { line_id -> veh/h }
      - "buses": { line_id -> nÂº buses }

    Parameters:
      path: path to the JSON file (optional).
            If not provided, it uses the default path:
            salida_red_simulada/lines_config_simulated.json
    """
    filepath = Path(path) if path is not None else LINES_CONFIG_FILE
    with filepath.open(encoding="utf-8") as f:
        data = json.load(f)
    return data


def load_network_maps(path: Optional[Path] = None) -> Dict[str, Any]:
    """
    Loads the JSON with the basic network maps.

    Returns a dictionary with:
      - "stop_to_distrito": { stop_id -> district (string "01".."21") }
      - "line_to_stops": { line_id -> [stop_id, ...] }
      - "lambda_base": { stop_id -> base demand (assigned population) }

    Parameters:
      path: path to the JSON file (optional).
            If not provided, it uses the default path:
            salida_red_simulada/network_maps.json
    """
    filepath = Path(path) if path is not None else NETWORK_MAPS_FILE
    with filepath.open(encoding="utf-8") as f:
        data = json.load(f)
    return data


# -----------------------------
# 3. High-Level Class: EngineData
# -----------------------------

class EngineData:
    """
    Convenience container that loads and exposes all the
    necessary information for the Intelligence Engine.

    Typical Usage:

        from engine_config import EngineData

        data = EngineData() # uses default paths

        # Basic Dictionaries:
        data.cycle_time_h
        data.prior_freq
        data.buses
        data.stop_to_distrito
        data.line_to_stops
        data.lambda_base

        # Useful Lists:
        data.lines
        data.stops
        data.distritos
    """

    def __init__(
        self,
        lines_config_path: Optional[Path] = None,
        network_maps_path: Optional[Path] = None,
    ) -> None:
        # Load raw data
        lines_cfg = load_lines_config(lines_config_path)
        net_maps = load_network_maps(network_maps_path)

        # Main Attributes (dictionaries)
        self.cycle_time_h: Dict[str, float] = {
            k: float(v) for k, v in lines_cfg.get("cycle_time_h", {}).items()
        }
        self.prior_freq: Dict[str, float] = {
            k: float(v) for k, v in lines_cfg.get("prior_freq", {}).items()
        }
        self.buses: Dict[str, int] = {
            k: int(v) for k, v in lines_cfg.get("buses", {}).items()
        }

        self.stop_to_distrito: Dict[str, str] = {
            k: str(v) for k, v in net_maps.get("stop_to_distrito", {}).items()
        }
        self.line_to_stops: Dict[str, List[str]] = {
            k: list(v) for k, v in net_maps.get("line_to_stops", {}).items()
        }
        self.lambda_base: Dict[str, float] = {
            k: float(v) for k, v in net_maps.get("lambda_base", {}).items()
        }

        # Useful derived attributes
        self.lines: List[str] = sorted(self.line_to_stops.keys())
        self.stops: List[str] = sorted(self.lambda_base.keys())
        self.distritos: List[str] = sorted(
            {d for d in self.stop_to_distrito.values() if d is not None}
        )

    # Auxiliary methods (optional, just syntactic sugar)

    def get_cycle_time(self, line_id: str) -> float:
        """Returns the cycle time (hours) for a line."""
        return self.cycle_time_h[line_id]

    def get_prior_freq(self, line_id: str) -> float:
        """Returns the prior frequency (veh/h) for a line."""
        return self.prior_freq[line_id]

    def get_stops_of_line(self, line_id: str) -> List[str]:
        """Returns the list of stops for a line."""
        return self.line_to_stops.get(line_id, [])

    def get_distrito_of_stop(self, stop_id: str) -> str:
        """Returns the district of a stop (or None if it doesn't have one)."""
        return self.stop_to_distrito.get(stop_id)

    def get_lambda_base_of_stop(self, stop_id: str) -> float:
        """Returns the base demand associated with a stop."""
        return self.lambda_base.get(stop_id, 0.0)